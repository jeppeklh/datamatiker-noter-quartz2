## a) Beskriv hvordan I arbejdede med verificering i jeres projekt og hvordan det påvirkede det endelige produkt.
---
Verificering handler om at sikre, at vi udvikler systemet **på den rigtige måde** – fra dag ét. Det handler ikke om _hvad_ vi bygger (det er **validering**), men om _hvordan_ vi bygger det. 
Det er en underdel **kvalitetssikring**. Vi har arbejdet aktivt og systematisk med det.

**Verificering** adskiller sig fra test **ved**, at testen kontrollerer **hvad** systemet gør (funktionalitet), mens **verificering** sikrer **hvordan** det er lavet korrekt efter krav og standarder.
### Fokus på kvalitet i både design og kode
---
Vi brugte **verificering** til løbende **kvalitetssikring** af både vores artefakter og kode:

#### Artefakt-verificering
---
Til verificering af artefakter stillede vi spørgsmål som:
- Er UML-diagrammer tegnet korrekt ift. notation (fx multiplicitet, aktører, swimlanes)?
- Er der **sporbarhed** mellem artefakter – fx stemmer vores SSD overens med use cases og DCD?
- Matcher klasser og metoder på tværs af DCD og sekvensdiagrammer?
    

#### Kode-verificering
---
Til verificering af kode stillede vi spørgsmål som:
- Overholder koden vores valgte standarder (SOLID, KISS, DRY)?
- Matcher implementationen designet (fx DTO-strukturer og lagdeling)?
- Reagerer metoder korrekt på forventede input/output?

Denne adskillelse gjorde det nemmere at sikre **kvaliteten** i flere fokusområder – både _high-level design_, _programmering_ og _test_.

### Anvendte teknikker, guidelines og tilpasninger
---

| Kategori                          | Principper og værktøjer                                                                              | Teamtilpasning / begrænsning                                                                                                                                                                                                                                                            |
| --------------------------------- | ---------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **UML- & BPMN**-artefakter        | Use Case-diagrammer, Domænemodel, DCD, SSD, Databasemodel- BPMN til forretningsflow<br>              | Vi tegnede "lo-fi" BPMN til intern diskussion uden streng notation.<br><br>Vores DCD er forenklet - vi droppede nogle relationer og forbindelser, for at holde diagrammet overskueligt, da teamet sad tæt og delte forståelse. Sporbarheden ofrede vi bevidst til fordel for læsbarhed. |
| **Tjeklister**/Egne kvalitetskrav | Projekt-specifikke tjeklister baseret på undervsningens artefakttyper                                | Vi havde en **tjekliste** for hver **atefakttype** (UML, kode osv.), så alle vidste præcis, hvad de skulle **kontrolleres** i hver gennemgang.<br><br>Brugtes både i opstart og løbende **verificering**.                                                                               |
| **Kodestandarder & arkitektur**   | SOLID, KISS, DRY  <br><br>                                                                           | Vi prioritede en **moduær** struktur: <br>tydelige adskillelse af lag og minimering af cirkulære afhængigheder gjorde koden lettere at teste.<br><br>Diagrammer fouserede på de vigtigste komponenter og detaljer blev drøfttet i fællesskab.                                           |
| **Peer-review & statisk analyse** | PullRequest-gennemgang med tjekpunkter for notation, SOLID, navngivning, formatering, sikkerhed osv. | Hver PullRequest blev manuelt **kvalitetssikret** af mindst af teammedlemmer.<br><br>Fejl blev fanget manuelt, før vi mergede til vores hovedbranch.                                                                                                                                    |


### Proces for verificering
---
**Fastlæggelse af kvalitetskriterier**
- I opstartsmødet definerede vi konkrete krav til hver artefakt: hvilken notation, hvilke kontrakter og kodestandarder, der skulle overholdes.
- Vi udviklede **tjeklister** for at skabe fælles reference

**Løbende artefakt- og kodegennemgange**
- Diagrammer blev gennemgået ift. **notationskrav** og **intern konsistens**.
- Hver Pull Request skulle godkendes ift. **mindst ét** **verificeringspunkt**. (Notation eler SOLID-princip)
- CI-pipelinen fangede formaterings- og sikkerhedsfejl automatisk.

**Afsluttende verificering**
- Slutproduktet blev gennemgået samlet – artefakter og kontrakter blev kvalitetssikret i et fælles møde.

_NB:_ **Verificering** handler ikke om funktionel test – det handler om at sikre struktur, konsistens og korrekt udført håndværk.
### Påvirkning af det endelige produkt
---
**Modularitet og testbarhed** 
Det har givet hurtigere tests og bedre mulighed for refaktorering pga klare laggrænser og få afhængigheder.

**Overskuelige artefakter**
Forenklede DCD og "lo-fi" BPMN gav et hurtigt overblik og fjernede støj. 
Da teamet sad samlet ved gennemgang, sikrede vi, at implicitte detaljer blev diskuteret grundigt.

**Forbedret kodekvalitet og vedligeholdelse**  
Strengt SOLID/KISS-fokus har **minimeret** **kompleksitet** i fx `RejsepakkeService` og gjort det **hurtigt** at **tilføje** nye **funktioner**.

**Fleksibilitet i designfasen**  
Lo-fi BPMN kunne hurtigt opdateres, hvilket skabte agilitet uden at miste overblik.


[[2. Spørgsmål#b) Forklar begreberne validering og verificering og beskriv deres sammenhæng til begreberne kvalitetssikring og sporbarhed| Validering og Verificering B spørgsmål]]

### Konklusion
---
Verificering har været en integreret del af vores proces – både i design og implementering. 

Vi har brugt den som et aktivt **værktøj** til **kvalitetssikring** og til at sikre et stabilt, forståeligt og udvidelsesklart system.

## B) redegør kort for de tre forskellige typer af mønstre: Konceptuelle, design og programmerings mønstre. Hvad kendetegner dem og hvad er formålet med dem?
---
Når vi arbejder med systemudvikling, møder vi ofte de samme typer udfordringer igen og igen. Derfor anvender vi **mønstre** – genbrugelige løsninger på velkendte problemer. Mønstre findes på tre niveauer:

**Konceptuelle mønstre** – hvad skal systemet indeholde og hvordan hænger delene sammen?

**Designmønstre** – hvordan strukturerer vi systemets klasser og moduler?

**Programmeringsmønstre**  –  hvordan skriver vi konkret kode, der er effektiv og vedligeholdbar?


## Konceptuelle mønstre
---
**Kendetegn**
- Meget abstrakte og ­uafhængige af programmeringssprog
- Beskriver systemets “black box”: aktører, scenarier og sammenhæng mellem funktioner
- Understøtter **kravindsamling** og tidlig analyse

**Formål**
- Skabe fælles **forståelsessprog** mellem udviklere og interessenter (nemmere **validering** af systemet)
- Kortlægge brugsmønstre og **usecases** før implementering

**Underkategorier**
- **Use Case-mønster (“Bestil vare”)**: Trin-for-trin-­beskrivelse af, hvordan en kunde søger, vælger, lægger i kurv og gennemfører betaling på en webshop.

- **Domaindriven design**: Identifikation af centrale begreber og relationer i domænet

- **Nudging (“Defaults”)**: Sætte den mest ønskede leveringsmetode som standardvalg for at styre brugerens valg uden at fratage dem valgfrihed.

Eksempel: 
[[10. Spørgsmål#Konceptuelt mønster Domain-Driven Design (DDD)|Domaindriven Design]]

## Designmønstre
---
**Kendetegn**
- Mellem abstraktionsniveau: sprog­**uafhængigt**, men knyttet til **objektorienteret design**
- Løser gentagne arkitektur- og struktur­problemer i systemets opbygning
- Opdelt i **Creational**, **Structural** og **Behavioral** mønstre
    

**Formål**
- Genbrug af afprøvede løsninger
- Øge fleksibilitet, vedligeholdelse og løse kobling
- Understøtte **best practices** i arkitektur og struktur

##### Creational patterns (oprettelse af objekter)
---
Creational patterns fokuserer på **hvordan objekter skabes** i et ­system. 

De kigger på **kompleksiteten** omkring **instantiation** ved at give rammer for at:
- Afkoble klientkode fra konkrete klassedefinitioner (Dependency injection)
- Håndtere livscyklus og konfiguration af objekter (_Singleton_)

Konkrete eksempler
- **Singleton**: Sikrer én global instans på tværs af systemet (f.eks. konfigurationsmanager).

- **Factory Method**: Udskyder valg af konkret objekt til underklasser.

Ved at anvende **creational patterns** sikrer man, at man kan oprette objekter på en **fleksibel**, **kontrolleret** og **genbrugelig** måde – uden at sprede “new”-kald eller tunge konstruktionsdetaljer ud i hele koden.

##### Structural patterns (sammensætning af objekter)
---
Structural patterns handler om, **hvordan klasser og objekter sammensættes** for at danne større enheder. 

De giver principper for at:
- Forenkle eller skjule **kompleksitet** i objekt­relationer
- Skabe **løse koblinge**r mellem komponenter
- Samarbejde mellem klasser uden at bryde principper om ansvar

**Konkrete eksempler** 
- **Adapter**: Tilpasser en klasse til et andet interface uden at ændre dens kode.
 
- **Decorator**: Tilføjer dynamisk ekstra funktionalitet til et objekt.

Structural patterns sikrer, at dit systems komponenter er **velorganiserede**, **genbrugelige** og **let udskiftelige**, selv når **kompleksiteten** vokser.

##### Behavioral patterns (kommunikation mellem objekter)
---
Behavioral patterns fokuserer på **hvordan objekter og klasser kommunikerer** og **samarbejder** for at udføre funktionalitet. 

De definerer protokoller og ansvarsfordelinger, så:
- Kommunikation mellem objekter kan håndteres ensartet
- Algoritmer eller arbejdsflow kan udskiftes uden at ændre de kaldende klasser
- Objektansvar er klart fordelt og løst koblet

**Konkrete eksempler**
- **Observer**: En-til-mange-opdatering (f.eks. UI, der følger ændringer i data).
    
- **Strategy**: Gør algoritmer udskiftelige (f.eks. sorteringsmetoder).


Med **behavioral patterns** opnår man et system, hvor **interaktion**, **skalerbarhed** og **udvidelse af adfærd** kan styres på en forudsigelig, løskoblet måde.


**Creational** = _Hvordan skaber vi objekter fleksibelt og kontrolleret?_
    
**Structural** = _Hvordan sammensætter vi objekter for at danne robuste, men let foranderlige systemer?_
    
**Behavioral** = _Hvordan fordeler og koordinérer vi ansvarsområder og interaktioner mellem objekter?_

## Programmeringsmønstre
---
**Kendetegn**
- Lavt abstraktionsniveau, ofte specifikt for et sprog eller framework
- Løser små, gentagne problemstillinger i kode­strukturen/koden

**Formål**
- Øge læsbarhed, ensartethed og genbrug
- Sikre ensartet fejlhåndtering og kontrolflow

**Eksempler**
- **Async/Await-mønster** (asynkrone I/O-kald uden at blokere tråde)
- **Try-Catch vs. TryParse** for forskellig fejlhåndtering i C#
- **Switch–case vs. if-else** 
- **LINQ** 

##### Streamlining
Det mest centrale ved **programmeringsmønstre** er **streamlining** – at vælge én fælles strategi/mønster og anvende den overalt i hele applikationen. 

SPRING OVER
F.eks. hvordan vi fanger og logger fejl:

- **Før streamlining:** Nogle steder blev fejl ubearbejdet skrevet til konsollen, mens andre steder brugte en logger. Dette førte til uensartede logformater og spredte fejloplysninger.
    
- **Efter streamlining:** Alle exceptions fanges med et fælles logger-interface, som skriver detaljeret fejlinformation med samme struktur til jeres valgte logkanal (f.eks. fil, database eller ekstern log-service). Samtidig sendes kun en generel, brugervenlig fejlbesked til UI’et, mens de tekniske detaljer gemmes til analyse.

### Sammenhæng
---
- **Konceptuelle mønstre** definerer _hvad_ systemet skal gøre (use cases, domæneevents).
    
- **Designmønstre** strukturerer _hvordan_ klasser og objekter samarbejder (Singleton, Observer).
    
- **Programmeringsmønstre** guider _hvordan_ koden konkret skrives i det valgte sprog (async/await, try-catch).
  
Ved at arbejde med mønstre på flere niveauer opnår vi **bedre kvalitet**, **hurtigere udvikling** og **mere robust software** – både nu og i fremtiden.

[[10. Spørgsmål#a) Beskriv med eksempler forskellige mønstre I har benyttet i jeres systemudviklingsproces og forklar fordele og ulemper ved at benytte disse mønstre.|Mønstre A spørgmål]]